---
slug: "como-os-navegadores-funcionam-por-debaixo-dos-panos"
title: "Como os navegadores funcionam por debaixo dos panos"
date: "20 de Mar√ßo de 2024"
subtitle: "Entender como os navegadores funcionam √© crucial pra quem trabalha ou pretende trabalhar com desenvolvimento web."
tags:
  - navegadores
  - frontend
  - navega√ß√£o
  - fetch
  - renderiza√ß√£o
---

<br/>

Atualmente os principais navegadores s√£o o Google Chrome, Mozilla Firefox, Microsoft Edge e Apple Safari, provavelmente voc√™ est√° usando um deles para acessar essa p√°gina. Cada navegador possui suas caracteristicas e recursos, nesse post irei explorar os processos de "**navega√ß√£o**‚Äù, "**fetch de dados**‚Äù e "**rederiza√ß√£o da p√°gina**‚Äù.
<br/>
Para o navegador exibir uma p√°gina na tela do nosso computador, ele precisa ter acesso aos recursos dessa p√°gina (HTML, CSS, JavaScript, imagens, videos, etc‚Ä¶) que est√£o armazenados em algum lugar e √© atrav√©s da navega√ß√£o que localizamos esses recursos.

<br/>
<br/>
<br/>

## 1. A Navega√ß√£o ‚õµÔ∏è 

<br/>
<br/>

Cada computador possui um identificador √∫nico chamado IP (Internet Protocol), ao informamos ao navegador que queremos acessar a p√°gina ‚Äúhttps://exemplo.com‚Äù, ele transforma o nome de dom√≠nio em um endere√ßo de IP ‚Äú192.7.2.34‚Äù, agora conhecendo o IP √© possivel localizar o computador que armazena os recursos da p√°gina que queremos acessar.
A convers√£o entre o nome de dom√≠nio para o endere√ßo de IP √© realizada atrav√©s de consulta ao servidor DNS (Domain Name System). O DNS √© muito semelhante a uma lista telefonica que associa um nome a um n√∫mero de telefone. 
<br/>
Essa requisi√ß√£o ao servidor DNS ocorre quando acessamos uma p√°gina pela primeira vez, depois disso o IP fica armazenado, e numa pr√≥xima vez que for visitar a p√°gina o acesso ser√° mais r√°pido.
<br/>
<br/>
Localizado o computador com os recursos da nossa p√°gina o navegador precisa abrir uma conex√£o atrav√©s do protocolo TCP (Transmission Control Protocol). O TCP √© um padr√£o de comunica√ß√£o que permite a troca de dados atrav√©s da internet, assegurando que os dados sejam entregues na ordem e no destino correto. 
<br/>
A conex√£o √© criada a partir de tr√™s vias ou handshake: 
<br/>
<br/>
1. o navegador envia um pacote SYN solicitando uma sincroniza√ß√£o.
<br/>
2. o servidor responde com um pacote SYN-ACK concordando com o processo.
<br/>
3. por fim o navegador envia o pacote ACK estabelecendo a conex√£o.
<br/>
<br/>
Para estabelecer uma conex√£o segura para a transmiss√£o dos dados, uma outra camada com um protocolo TSL (Transport Security Layer) √© aplicado. O TSL √© um protocolo que aplica uma criptografia aos dados.
<br/>
O protocolo TSL consiste nas seguintes etapas:
<br/>
<br/>
1. o navegador envia uma solicita√ß√£o de seguran√ßa ao servidor.
<br/>
2. o servidor responde a solicita√ß√£o de seguran√ßa e envia o certificado SSL ao navegador.
<br/>
3. o navegador verifica a autenticidade do certificado SSL e envia para o servidor qual o algoritmos de criptografia e os m√©todos de autentica√ß√£o que ser√£o usados.
<br/>
4. por fim √© estabelecido uma conex√£o segura.
<br/>
<br/>
Agora que temos uma conex√£o segura, o navegador ir√° pegar os recursos necess√°rios para montar a p√°gina dando inicio o pr√≥ximo passo o fetch dos dados.
<br/>

<br/>
<br/>

## 2. O Fetch dos dados üêï

<br/>
<br/>

Para buscar os recursos da p√°gina o navegador envia uma requisi√ß√£o HTTP/GET solicitando inicialmente o HTML da p√°gina. O HTTP (Hypertext Transfer Protocol) √© um protocolo de comunica√ß√£o baseado no modelo cliente-servidor (entenda que o cliente √© o navegador). Esse modelo consiste em solicita√ß√µes enviadas pelo navegador para obter um recurso, e em contra partida, o servidor responde a solicita√ß√£o enviando para o navegador o recurso pedido, caso ele exista.
<br/>
Toda solicita√ß√£o ou requisi√ß√£o HTTP consiste de um cabe√ßalho (header) e opcionalmente um corpo (body), no cabe√ßalho cont√©m uma s√©rie de informa√ß√µes, mas as principais s√£o o m√©todo HTTP (GET, POST, PUT, DELTE, etc‚Ä¶) e a URI (Uniform Resource Identifier) que indica qual o recurso o nevagador est√° buscando.
<br/>
<br/>
O servidor ao receber a solicita√ß√£o enviada pelo navegador ir√° processar a informa√ß√£o e enviar uma resposta HTTP ao navegador. Essa resposta tamb√©m consiste de um cabe√ßalho contendo v√°rias informa√ß√µes, sendo a principal o status code (200 OK, 404 Not Found, etc‚Ä¶) que nos informa se o processamento ocorreu com sucesso ou se houve alguma falha. 
<br/>
<br/>
üëâüèª¬†Caso queira ver isso acontecendo basta inspecionar a p√°gina e ir na aba "network‚Äù ou "rede‚Äù e navegar para uma p√°gina qualquer.
<br/>
<br/>
O tempo em que a solicita√ß√£o √© disparada pelo navegador at√© o recebimento dos primeiros pacotes de dados √© conhecido por <span>Time to First Byte</span> (TTFB).
<br/>
<br/>
A velocidade de trasmiss√£o desses pacotes de recursos (conhecidos como <span>chunks</span>) √© controlado por um <span>algoritimo de cogestionamento</span> que tem como objetivo manter uma estabilidade no fluxo de chunks enviados.
<br/>
Depois que cada chunk √© recebido pelo navegador uma mensagem ACK √© enviada para o servidor, como a conex√£o entre navegador e servidor √© limitada, caso o servidor dispare muitos pacotes de chunks rapidamente eles ser√£o perdidos e o navagador n√£o ir√° retornar nenhuma messagem ACK e √© aqui que o algoritimo de congestionamento entra em a√ß√£o monitorando esse fluxo de pacotes de chunks e mensagens ACK, afim de, encontrar uma taxa de transmiss√£o ideal criando um fluxo constante.
<br/>
<br/>
At√© agora vimos como o navegador realiza o processo de navega√ß√£o e fetch dos recursos, chegou a hora de iniciar o √∫ltimo passo a rederiza√ß√£o da p√°gina.

<br/>
<br/>
<br/>

## 3. Renderiza√ß√£o üñ•Ô∏è

<br/>
<br/>
Antes de detalhar como o navegador exibe na tela do nosso computador os recursos obtidos na etapa anterior, √© preciso conhecer seu principal componente, <span>a engine</span>. 
<br/>
Existem muitas engines e algumas delas s√£o apresentadas a seguir:
<br/>
<br/>
- Gecko: desenvolvida pela equipe do Mozilla  para o Firefox e escrita em C++, JavaScript e Rust.
<br/>
- WebKit: desenvolvido pela Apple para o Safari, escrita em C++.
<br/>
- Blink: desenvolvida pelo Google para o Chrome, escrita em C++.
<br/>
<br/>
A principal fun√ß√£o da engine √© combinar a estrutura HTML, o estilo CSS e descobrir quais s√£o os trechos de c√≥digo que s√£o interativos.
<br/>
<br/>
Ent√£o para exibir a p√°gina a engine do navegador inicia o processo de parse do HTML. 
O parse corresponde ao processo de analise e interpreta√ß√£o da sequencia dos dados, e envolve duas etapas a tokeniza√ß√£o e a constru√ß√£o da DOM (Document Object Model). Para ilustrar o parse considere o HTML a seguir: 
<br/>
<br/>

![html-exemplo](/images/como-os-navegadores-funcionam-por-debaixo-dos-panos/html-exemplo.png)

<br/>
<br/>
Na etapa de tokeniza√ß√£o o navegador realiza uma analise l√©xica separando em tokens que representa elementos HTML, como mostra a seguir:
<br/>
<br/>
- tag de abertura: html <br/>
- tag de abertura : head <br/>
- tag de abertura: title <br/>
- texto da tag title: Meu t√≠tulo <br/>
- tag de fechamento: title <br/>
- tag de fechamento: head <br/>
- tag de abertura: body <br/>
- tag de abertura: h1 <br/>
- tag de abertura: h1 <br/>
- texto da tag h1: Ol√° Mundo! <br/>
- tag de fechamento: h1 <br/>
- tag de fechamento: body <br/>
- tag de fechamento: html <br/>

<br/>
Ap√≥s a cria√ß√£o dos tokens √© iniciada a constru√ß√£o da DOM que representa a estrutura hier√°rquica do documento HTML
<br/>
<br/>

```jsx

 - html
    - head
      - title
        - Text: "Meu t√≠tulo"
    - body
      - h1
        - Text: "Ol√°, mundo!"

```
<br/>

Neste exemplo, o primeiro n√≥ representa uma tag html que dentro dela possui um outro n√≥ representado pela tag head e dentro desse elemento possui um n√≥ title como o texto "Meu t√≠tulo‚Äù. O n√≥ body como o mesmo n√≠vel de hieraquia que o n√≥ head representa a tag body que possui um n√≥ representando a tag h1 que cont√©m o texto "Ol√° mundo!‚Äù. 
<br/>
O processo de parse ocorre linha por linha do top do arquivo para baixo. Em navegadores antigos quando o parse se deparava com um recurso bloqueante (como uma image, arquivo Javascript, etc,) o processo de parse era interropindo e o navegador enviava uma requisi√ß√£o solicitando o recurso ao servidor para depois retomar o processo, hoje os navegadores possuem <span>pr√©-carregadores</span> ou <span>pre-loader</span> que realizam uma varredura buscando pelos recursos bloqueantes que s√£o recuperados em segundo plano, a fim de, evitar o bloqueio do parse.
<br/>
<br/>
Depois de concluido o parse do HTML √© a vez de realizar o parse do CSS. As regras de estiliza√ß√£o da p√°gina podem estar contida tanto no pr√≥prio arquivo HTML quanto em uma folha de estilo separada. E de modo similar ao parse do HTML, o parse do CSS inicia com a tokeniza√ß√£o dando origem aos n√≥s que ir√£o formar a √°rvore CSSOM (Cascading Style Sheets Object Model) que consistem em uma estrutura de dados independente da DOM.
<br/>
Para ilustrar o parse do CSS vamos utilizar o exemplo a seguir:

<br/>
<br/>

```CSS
body {
	font-size: 16px;
	background-color: black;
}

h1 {
	color: white;
	font-size: 32px;
}

div {
	background-color: red;
}

```

<br/>

Para o CSS acima a CSSOM seria algo como mostra a figura a seguir:

<br/>

![cssom-example](/images/como-os-navegadores-funcionam-por-debaixo-dos-panos/ccsom-example.png)

<br/>
O esquema acima mostra que o elemento h1 herda a propriedade color com o valor white do body, elemento de maior hier√°rquia, enquanto a propriedade font-size √© sobrescrita alterando seu valor de 16px para 32px, de modo semelhante, o elemento div herda a propriedade font-size do body e sobrescreve as propriedades background-color e color atribuindo novos valores.
<br/>
<br/>
Como podemos ver o navegador come√ßa aplicando a regra mais geral e segue refinando aplicando regras mais especificas seguindo o princ√≠pio de cascata de estilos. Em alguns casos o mesmo elemento pode ter diferentes regras de estiliza√ß√£o e nesse caso o navegador deve determinar qual regra ser√° aplicada. Para isso √© usada uma ordem de especificidade no CSS, como mostra a seguir: 
<br/>
<br/>
CSS Inline > ID > Classe/Atributo/Pseudo-Classe > Elemento/Pseudo-Elemento e permanecendo o empate prevalece a regra que foi aplicada por √∫ltimo.
<br/>
<br/>
As regras CSS s√£o aplicadas da direita para a esqueda, ou seja, caso o navegador encontre a seguinte regra 

<br/>

```CSS 
div p { 
  color: red 
}
```  
<br/>
ele ir√° buscar por todas as tags p e verificar qual delas tem uma tag div como elemento pai e ent√£o aplicar a propriedade color com o valor red.
<br/>
<br/>
Nossa p√°gina j√° possui uma estrutura HTML e o estilo CSS, agora falta a interatividade proveniente do JavaScript. 
<br/>
<br/>
Antes de executar o c√≥digo JavaScript os navegadores precisam transpilar o c√≥digo, ou seja, converter o c√≥digo que utiliza uma sint√°xe mais moderna em uma vers√£o de c√≥digo com uma sint√°xe mais antiga. Para realizar a tranpila√ß√£o o navegador faz o parse do c√≥digo transformando em uma estrutura AST (Abstract Syntax Tree) como mostra o exemplo a seguir:
<br/>
<br/>

```jsx
const name = "Paula"
```

<br/>

![AST-tree-example](/images/como-os-navegadores-funcionam-por-debaixo-dos-panos/AST-tree-example.png)

<br/>

Com essa estrutura o navegador √© capaz de manipular os n√≥s, substituindo para a vers√£o mais antiga, e ap√≥s a manipula√ß√£o dos n√≥s o navegador faz o processo reverso reconstruindo o c√≥digo. 
<br/>
üëâüèª¬†Caso queira explorar a estrutura AST voc√™ pode acessar a ferramenta https://astexplorer.net/.
<br/>
<br/>
Com o c√≥digo na sintaxe aceita pelo navegador ele ser√° executado pela engine JavaScript. As principais engine JavaScript s√£o:
<br/>
<br/>
- V8:  √© o motor JavaScript de alta performance utilizado no Google Chrome e no Node.js, escrito em C++ <br/>
- JavaScriptCore: utilizada em dispositivos macOS como o Apple Safari <br/>
- Chakra: desenvolvido pela Microsoft e escrito em C++ para o Edge <br/>
- SpiderMonkey: utilizado pelo Mozilla no Firefox, escrito em C++ e Rust <br/>
<br/>
As engines JavaScript de navegadores modernos possui a capacidade de fazer o que √© chamado de <span>Just-In-Time (JIT) compilation </span> que consiste no melhor dos mundos entre a compila√ß√£o e interpreta√ß√£o de c√≥digo.
<br/>
Enquanto o c√≥digo est√° sendo interpretado e executado em tempo real um monitor verifica trechos de c√≥digo que se repetem, esses trechos de c√≥digo √© enviado para a compila√ß√£o, de modo que, ao se deparar com algum desses trechos ao inv√©s de realizar a sua interpreta√ß√£o o c√≥digo compilado √© extraido.
<br/>
<br/>
 üëâüèª¬†Para ver mais detalhes sobre JIT acesse o site https://hacks.mozilla.org/2017/02/a-crash-course-in-just-in-time-jit-compilers/
 <br/>
 <br/>